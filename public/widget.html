<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: system-ui, sans-serif; background: #1a1a2e; }
    canvas { display: block; width: 100%; height: 100%; }
    .info { position: absolute; bottom: 16px; left: 16px; color: rgba(255,255,255,.9); font-size: 16px; font-weight: 600; text-shadow: 0 1px 3px rgba(0,0,0,.5); }
    .loading { display: flex; align-items: center; justify-content: center; height: 100%; color: white; font-size: 18px; }
  </style>
</head>
<body>
  <div id="loading" class="loading">Loading particles...</div>
  <canvas id="c" style="display:none;"></canvas>
  <div class="info" id="info"></div>
  
  <script>
    function render() {
      // Get data from ChatGPT's toolOutput
      const data = window.openai?.toolOutput;
      
      if (!data || !data.config) {
        document.getElementById('loading').textContent = 'Waiting for particle config...';
        return;
      }
      
      const cfg = data.config;
      
      // Hide loading, show canvas
      document.getElementById('loading').style.display = 'none';
      document.getElementById('c').style.display = 'block';
      document.body.style.background = cfg.background;
      document.getElementById('info').textContent = cfg.name;
      
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');
      
      function resize() { 
        canvas.width = window.innerWidth; 
        canvas.height = window.innerHeight; 
      }
      window.addEventListener('resize', resize);
      resize();
      
      const particles = [];
      for (let i = 0; i < cfg.particles.count; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          s: cfg.particles.size[0] + Math.random() * (cfg.particles.size[1] - cfg.particles.size[0]),
          vx: (Math.random() - 0.5) * cfg.particles.speed,
          vy: (Math.random() - 0.5) * cfg.particles.speed,
          o: 0.3 + Math.random() * 0.7,
          ph: Math.random() * Math.PI * 2
        });
      }
      
      function getColor(p) {
        if (cfg.particles.color === 'rainbow') return `hsl(${(Date.now()/50 + p.ph*100) % 360}, 80%, 60%)`;
        if (cfg.particles.color === 'multi') {
          const cs = ['#ff6b6b','#4ecdc4','#45b7d1','#96ceb4','#ffeaa7'];
          return cs[Math.floor(p.ph * cs.length) % cs.length];
        }
        return cfg.particles.color;
      }
      
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (const p of particles) {
          const t = cfg.particles.type;
          
          if (t === 'star') { 
            p.x += p.vx * 0.1; 
            p.y += p.vy * 0.1; 
            if (cfg.particles.twinkle) p.o = 0.3 + Math.abs(Math.sin(Date.now()/1000 + p.ph)) * 0.7; 
          }
          else if (t === 'snow') { 
            p.x += Math.sin(Date.now()/2000 + p.ph) * 0.5; 
            p.y += cfg.particles.speed * 0.5; 
            if (p.y > canvas.height) { p.y = -p.s; p.x = Math.random() * canvas.width; } 
          }
          else if (t === 'rain') { 
            p.y += cfg.particles.speed; 
            if (p.y > canvas.height) { p.y = -p.s; p.x = Math.random() * canvas.width; } 
          }
          else if (t === 'bubble') { 
            p.x += Math.sin(Date.now()/1500 + p.ph) * 0.5; 
            p.y -= cfg.particles.speed * 0.3; 
            if (p.y < -p.s) { p.y = canvas.height + p.s; p.x = Math.random() * canvas.width; } 
          }
          else if (t === 'petal') { 
            p.x += Math.sin(Date.now()/1000 + p.ph); 
            p.y += cfg.particles.speed; 
            if (p.y > canvas.height) { p.y = -p.s; p.x = Math.random() * canvas.width; } 
          }
          else if (t === 'glow') { 
            p.x += Math.sin(Date.now()/2000 + p.ph) * 0.5; 
            p.y += Math.cos(Date.now()/2000 + p.ph) * 0.5; 
            if (cfg.particles.pulse) p.o = 0.2 + Math.abs(Math.sin(Date.now()/500 + p.ph)) * 0.8; 
          }
          else if (t === 'wave') { 
            p.x += cfg.particles.speed; 
            p.y += Math.sin(Date.now()/1000 + p.ph) * 0.5; 
            if (p.x > canvas.width) p.x = -p.s; 
          }
          else if (t === 'aurora') { 
            p.x += Math.sin(Date.now()/3000 + p.ph) * 2; 
            p.y += Math.cos(Date.now()/4000 + p.ph) * 0.5; 
            p.o = 0.3 + Math.abs(Math.sin(Date.now()/2000 + p.ph)) * 0.5; 
          }
          else if (t === 'galaxy') { 
            const cx = canvas.width/2, cy = canvas.height/2;
            const a = Math.atan2(p.y-cy, p.x-cx) + cfg.particles.speed * 0.01;
            const d = Math.sqrt((p.x-cx)**2 + (p.y-cy)**2);
            p.x = cx + Math.cos(a) * d; 
            p.y = cy + Math.sin(a) * d; 
          }
          else if (t === 'fire') { 
            p.y -= cfg.particles.speed * (0.5 + Math.random() * 0.5); 
            p.x += Math.sin(Date.now()/500 + p.ph) * 0.5; 
            p.o -= 0.01; 
            if (p.o <= 0 || p.y < 0) { 
              p.y = canvas.height; 
              p.x = canvas.width/2 + (Math.random() - 0.5) * 100; 
              p.o = 0.8; 
            } 
          }
          else { p.x += p.vx; p.y += p.vy; }
          
          // Wrap around
          if (p.x < -p.s) p.x = canvas.width + p.s;
          if (p.x > canvas.width + p.s) p.x = -p.s;
          if (!['snow','rain','bubble','petal','fire'].includes(t)) {
            if (p.y < -p.s) p.y = canvas.height + p.s;
            if (p.y > canvas.height + p.s) p.y = -p.s;
          }
          
          ctx.globalAlpha = p.o;
          const color = getColor(p);
          
          if (t === 'rain') { 
            ctx.beginPath(); 
            ctx.moveTo(p.x, p.y); 
            ctx.lineTo(p.x, p.y + p.s * 3); 
            ctx.strokeStyle = color; 
            ctx.stroke(); 
          }
          else if (t === 'bubble') { 
            ctx.beginPath(); 
            ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2); 
            ctx.strokeStyle = color; 
            ctx.stroke(); 
          }
          else if (['glow','aurora','fire'].includes(t)) { 
            const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.s * 3);
            g.addColorStop(0, color);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.s * 3, 0, Math.PI * 2);
            ctx.fill();
          }
          else { 
            ctx.beginPath(); 
            ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2); 
            ctx.fillStyle = color;
            if (t === 'star') { ctx.shadowColor = color; ctx.shadowBlur = p.s * 2; }
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }
        requestAnimationFrame(draw);
      }
      draw();
    }
    
    // Render on load
    window.addEventListener('load', render);
    
    // Also try to render immediately in case openai is already available
    if (window.openai?.toolOutput) {
      render();
    }
  </script>
</body>
</html>
