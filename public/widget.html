<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <style>
      html, body { margin: 0; height: 100%; }
      body { overflow: hidden; font-family: system-ui, sans-serif; background: #1a1a2e; }
      #hud {
        position: fixed; top: 12px; left: 12px;
        background: rgba(0,0,0,0.35);
        color: white; padding: 10px 12px;
        border-radius: 12px;
        backdrop-filter: blur(6px);
        z-index: 10;
      }
      #hud .title { font-size: 18px; font-weight: 700; }
      #hud .info { opacity: 0.85; font-size: 13px; margin-top: 4px; }
      button { margin-top: 8px; padding: 6px 12px; border-radius: 6px; border: none; cursor: pointer; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <div id="hud">
      <div class="title" id="title">Loading…</div>
      <div class="info" id="info"></div>
      <button id="refresh">✨ New Scene</button>
    </div>

    <script>
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");

      let particles = [];
      let cfg = null;

      function resize() {
        canvas.width = window.innerWidth * devicePixelRatio;
        canvas.height = window.innerHeight * devicePixelRatio;
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      }
      window.addEventListener("resize", resize);
      resize();

      function initParticles() {
        const p = cfg?.config?.particles ?? {};
        const count = p.count ?? 150;
        const sizeRange = p.size ?? [2, 5];
        const speed = p.speed ?? 1;

        particles = Array.from({ length: count }, () => ({
          x: Math.random() * window.innerWidth,
          y: Math.random() * window.innerHeight,
          r: sizeRange[0] + Math.random() * (sizeRange[1] - sizeRange[0]),
          vy: speed * (0.5 + Math.random()),
          vx: (Math.random() - 0.5) * speed,
          o: 0.3 + Math.random() * 0.7,
          ph: Math.random() * Math.PI * 2
        }));
      }

      function renderHud() {
        document.getElementById("title").textContent = cfg?.config?.name ?? "Particles";
        const p = cfg?.config?.particles ?? {};
        document.getElementById("info").textContent = `${p.count ?? 150} particles • ${p.type ?? 'float'}`;
      }

      function applyBackground() {
        const bg = cfg?.config?.background;
        if (bg) document.body.style.background = bg;
      }

      function getColor(p) {
        const color = cfg?.config?.particles?.color ?? '#ffffff';
        if (color === 'rainbow') return `hsl(${(Date.now()/50 + p.ph*100) % 360}, 80%, 60%)`;
        if (color === 'multi') {
          const cs = ['#ff6b6b','#4ecdc4','#45b7d1','#96ceb4','#ffeaa7'];
          return cs[Math.floor(p.ph * cs.length) % cs.length];
        }
        return color;
      }

      function tick() {
        if (!cfg) return requestAnimationFrame(tick);

        const W = window.innerWidth;
        const H = window.innerHeight;
        ctx.clearRect(0, 0, W, H);

        const t = cfg?.config?.particles?.type ?? 'float';
        const speed = cfg?.config?.particles?.speed ?? 1;

        for (const p of particles) {
          // Movement based on type
          if (t === 'star') {
            p.x += p.vx * 0.1;
            p.y += p.vy * 0.1;
            if (cfg?.config?.particles?.twinkle) p.o = 0.3 + Math.abs(Math.sin(Date.now()/1000 + p.ph)) * 0.7;
          }
          else if (t === 'snow') {
            p.x += Math.sin(Date.now()/2000 + p.ph) * 0.5;
            p.y += speed * 0.5;
            if (p.y > H) { p.y = -10; p.x = Math.random() * W; }
          }
          else if (t === 'rain') {
            p.y += speed;
            if (p.y > H) { p.y = -10; p.x = Math.random() * W; }
          }
          else if (t === 'bubble') {
            p.x += Math.sin(Date.now()/1500 + p.ph) * 0.5;
            p.y -= speed * 0.3;
            if (p.y < -10) { p.y = H + 10; p.x = Math.random() * W; }
          }
          else if (t === 'petal') {
            p.x += Math.sin(Date.now()/1000 + p.ph);
            p.y += speed;
            if (p.y > H) { p.y = -10; p.x = Math.random() * W; }
          }
          else if (t === 'glow') {
            p.x += Math.sin(Date.now()/2000 + p.ph) * 0.5;
            p.y += Math.cos(Date.now()/2000 + p.ph) * 0.5;
            if (cfg?.config?.particles?.pulse) p.o = 0.2 + Math.abs(Math.sin(Date.now()/500 + p.ph)) * 0.8;
          }
          else if (t === 'wave') {
            p.x += speed;
            p.y += Math.sin(Date.now()/1000 + p.ph) * 0.5;
            if (p.x > W) p.x = -10;
          }
          else if (t === 'aurora') {
            p.x += Math.sin(Date.now()/3000 + p.ph) * 2;
            p.y += Math.cos(Date.now()/4000 + p.ph) * 0.5;
            p.o = 0.3 + Math.abs(Math.sin(Date.now()/2000 + p.ph)) * 0.5;
          }
          else if (t === 'galaxy') {
            const cx = W/2, cy = H/2;
            const a = Math.atan2(p.y-cy, p.x-cx) + speed * 0.01;
            const d = Math.sqrt((p.x-cx)**2 + (p.y-cy)**2);
            p.x = cx + Math.cos(a) * d;
            p.y = cy + Math.sin(a) * d;
          }
          else if (t === 'fire') {
            p.y -= speed * (0.5 + Math.random() * 0.5);
            p.x += Math.sin(Date.now()/500 + p.ph) * 0.5;
            p.o -= 0.01;
            if (p.o <= 0 || p.y < 0) { p.y = H; p.x = W/2 + (Math.random()-0.5)*100; p.o = 0.8; }
          }
          else {
            p.x += p.vx;
            p.y += p.vy;
          }

          // Wrap
          if (p.x < -10) p.x = W + 10;
          if (p.x > W + 10) p.x = -10;
          if (!['snow','rain','bubble','petal','fire'].includes(t)) {
            if (p.y < -10) p.y = H + 10;
            if (p.y > H + 10) p.y = -10;
          }

          ctx.globalAlpha = p.o;
          const color = getColor(p);

          if (t === 'rain') {
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x, p.y + p.r * 3);
            ctx.strokeStyle = color;
            ctx.stroke();
          }
          else if (t === 'bubble') {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
          else if (['glow','aurora','fire'].includes(t)) {
            const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3);
            g.addColorStop(0, color);
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r * 3, 0, Math.PI * 2);
            ctx.fill();
          }
          else {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fillStyle = color;
            if (t === 'star') { ctx.shadowColor = color; ctx.shadowBlur = p.r * 2; }
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }

        requestAnimationFrame(tick);
      }

      function renderFromToolOutput() {
        cfg = window.openai?.toolOutput;
        if (!cfg) {
          document.getElementById("title").textContent = "Waiting for data...";
          return;
        }

        applyBackground();
        renderHud();
        initParticles();
      }

      // Refresh button calls the tool again
      document.getElementById("refresh").addEventListener("click", async () => {
        if (window.openai?.callTool) {
          await window.openai.callTool("quick_preset", { preset: "starryNight" });
          renderFromToolOutput();
        }
      });

      window.addEventListener("load", () => {
        renderFromToolOutput();
        tick();
      });

      // Also render if openai is already available
      if (window.openai?.toolOutput) {
        renderFromToolOutput();
      }
    </script>
  </body>
</html>
